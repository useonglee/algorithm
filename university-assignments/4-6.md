【问题描述】一个合法的身份证号码由 17 位地区、日期编号和顺序编号加 1 位校验码组成。校验码的计算规则如下：

首先对前 17 位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对 11 取模得到值 Z；最后按照以下关系对应 Z 值与校验码 M 的值：

Z：0 1 2 3 4 5 6 7 8 9 10

M：1 0 X 9 8 7 6 5 4 3 2

现在给定一些身份证号码，请你验证校验码的有效性，这里并不检验前 17 位是否合理，只检查前 17 位是否全为数字且最后 1 位校验码正确，并输出结果。

【输入格式】第一行输入正整数 N（≤100），表示输入的身份证号码的个数；随后 N 行，每行给出 1 个 18 位身份证号码。

【输出格式】按照输入的顺序每行输出 1 个有问题的身份证号码。如果所有号码都正常，则输出 All passed。

【输入样例 1】

4

320124198808240056

12010X198901011234

110108196711301866

37070419881216001X

【输出样例 1】

12010X198901011234

110108196711301866

37070419881216001X

【输入样例 2】

2

320124198808240056

110108196711301862

【输出样例 2】

All passed

```python
# input = ['320124198808240056', '12010X198901011234', '110108196711301866', '37070419881216001X']
input = ['320124198808240056', '110108196711301862']
N = len(input)

weight = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]
Mlist = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"]

failed = set()

for i in range(0, N):
  sum = 0
  for j, k in enumerate(input[i][:-1]):
    if k.isdigit() != True:
      failed.add(input[i])
      break

    sum += int(k) * weight[j]

  if Mlist[sum % 11] != input[i][-1]:
    failed.add(input[i])

if len(failed) == 0:
  print('All passed')

else:
  for i in input:
    if i in failed:
      print(i)
```
